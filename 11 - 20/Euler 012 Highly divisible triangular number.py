"""
https://projecteuler.net/problem=12

The sequence of triangle numbers is generated by adding the natural numbers.
So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28.
The first ten terms would be:
1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:
 1: 1
 3: 1,3
 6: 1,2,3,6
10: 1,2,5,10
15: 1,3,5,15
21: 1,3,7,21
28: 1,2,4,7,14,28
We can see that 28 is the first triangle number to have over five divisors.

What is the value of the first triangle number to have over five hundred divisors?
"""
#Determinining the number of factors of a number is easy once you know its
#prime factors. The prime factors of the n'th triangular number, n*(n+1)//2,
#are easy to obtain if you know the prime factors of n and n+1.
#Thus this problem is finding the prime factorization of a bunch of numbers

import time
start=time.clock()


#returns a list where sieve[i] = a prime factor of i (not all of them)
def modifiedPrimeSieve(limit):
    sieve = []
    for num in range(limit + 1):
        sieve.append(num)

    #each element is initiliazed with its index
    #then every 2nd element will be assigned 2
    #then every 3rd element will be assigned 3
    #then every 5th element will be assigned 5
    #etc (with more prime numbers)
    #If i come across an index that is prime, p, it will still have its index
    #as its value and I will know to reassign every p elements to be p.
    #if the value isnt the index, then the number isn't prime

    #even numbers have 2 as a factor
    sieve[2:limit+1:2] = [2] * (limit // 2)

    
    maxPrime = int( limit ** 0.5 ) #need only check for primes <= sqrt limit
    #skipping the even numbers
    for odd in range(3,maxPrime+1,2): #3,5,7, ...
        if sieve[odd] == odd:
        #the number's largest prime factor is itself, thus it is prime
            sieve[odd : limit + 1 : odd] = [odd] * (limit // odd)
    return sieve

#create a list where sieve[i] = a prime factor of i
sieve = modifiedPrimeSieve(10**5) #10**5 is overkill

#Given a number n = p^a * q^b * r^c ... * s^d. The number of prime factors is
#given by the product (a + 1) * (b + 1) * (c + 1) * ... * (d + 1)
#suppose we have a list of prime factors, [2,2,2,3,3,5,7].
#We will use this func calculate the number of factors
def numFactors(factList):
    #edge case
    if factList==[]:
        return 0
    
    ans=1
    currentPrime = factList[0]
    frequency=1
    index=1
    
    while index < len( factList ) :
        if factList[index] == currentPrime:
            frequency+=1
            index+=1
        else:
            ans*=(frequency+1)
            frequency=1
            currentPrime=factList[index]
            index+=1
    ans*=(frequency+1)
    return ans


#clearly the 0th and 1st triangular number do not have 500 factors
#so we can skip to 2
num = 2
sieve[:2]=[[], []] #since 0 and 1 have no prime factors

#we will loop through, figuring out the factors of num and checking if the
#(num - 1)th triangular number has over 500 factors.

while True:
    #make sieve[num] which is an int, be an unordered list of num's prime factors
    #note that (p * (a*b)) has prime factor 'p' and the prime factors of (a*b)
    #thus we can use dynamic programming to help us out
    if sieve[num] == num: #case where num is prime
        sieve[num] = [sieve[num] ]
    else: #case where num is composite, sieve[num] is a prime factor of num.
        factor = sieve[num]
        sieve[num] = [factor] + sieve[ num // factor ]

    #now we will determine the prime factors of the (NUM - 1)th triangle number
    #the (NUM - 1)th triangle number is ((NUM - 1) * NUM) // 2
    triFactors = sorted( sieve[num] + sieve[num-1] )[1:]
    #the [1:] removes the first element, a 2 factor
    if numFactors( triFactors ) > 500:
        break
    
    num+=1

ans = (num * (num - 1)) //2




print("Answer",ans,(time.clock()-start)*1000,"ms")
